Dateiname: Controllers\ApiKeyController.php
<?php

namespace App\Http\Controllers;

use App\Models\ApiKey;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Illuminate\Support\Facades\Auth;

class ApiKeyController extends Controller
{
    public function index()
    {
        $apiKeys = ApiKey::where('user_id', Auth::id())
            ->orderBy('provider')
            ->get();

        // Don't expose the full key, but provide a masked version
        $apiKeys->transform(function ($apiKey) {
            $apiKey->masked_key = $this->maskApiKey($apiKey->key);
            return $apiKey;
        });

        return Inertia::render('Pages/ApiKeys/Index', [
            'apiKeys' => $apiKeys
        ]);
    }

    protected function maskApiKey($key)
    {
        if (strlen($key) <= 8) {
            return '********';
        }

        return substr($key, 0, 4) . '...' . substr($key, -4);
    }

    public function store(Request $request)
    {
        $request->validate([
            'provider' => 'required|string',
            'key' => 'required|string',
            'label' => 'nullable|string|max:255',
            'is_default' => 'boolean',
        ]);

        // If this is set as default, unset others for this provider
        if ($request->is_default) {
            ApiKey::where('user_id', Auth::id())
                ->where('provider', $request->provider)
                ->update(['is_default' => false]);
        }

        $apiKey = ApiKey::create([
            'user_id' => Auth::id(),
            'provider' => $request->provider,
            'key' => $request->key,
            'label' => $request->label,
            'is_default' => $request->is_default ?? false,
        ]);

        return redirect()->route('api-keys.index')
            ->with('success', 'API key added successfully.');
    }

    public function update(Request $request, ApiKey $apiKey)
    {
        if ($apiKey->user_id !== Auth::id()) {
            abort(403);
        }

        $request->validate([
            'label' => 'nullable|string|max:255',
            'is_default' => 'boolean',
        ]);

        // If new key is provided, validate and update it
        if ($request->filled('key')) {
            $request->validate([
                'key' => 'required|string',
            ]);

            $apiKey->key = $request->key;
        }

        // If this is set as default, unset others for this provider
        if ($request->is_default && !$apiKey->is_default) {
            ApiKey::where('user_id', Auth::id())
                ->where('provider', $apiKey->provider)
                ->update(['is_default' => false]);
        }

        $apiKey->label = $request->label;
        $apiKey->is_default = $request->is_default ?? $apiKey->is_default;
        $apiKey->save();

        return redirect()->route('api-keys.index')
            ->with('success', 'API key updated successfully.');
    }

    public function destroy(ApiKey $apiKey)
    {
        if ($apiKey->user_id !== Auth::id()) {
            abort(403);
        }

        $apiKey->delete();

        return redirect()->route('api-keys.index')
            ->with('success', 'API key deleted successfully.');
    }
}



Dateiname: Controllers\Controller.php
<?php

namespace App\Http\Controllers;

abstract class Controller
{
    //
}



Dateiname: Controllers\DashboardController.php
<?php

namespace App\Http\Controllers;

use App\Models\ApiKey;
use App\Models\Prompt;
use App\Models\Workflow;
use App\Models\ExecutionLog;
use Illuminate\Http\Request;
use Inertia\Inertia;

class DashboardController extends Controller
{
    public function index()
    {
        // Authentifizierten Benutzer abrufen
        $user = auth()->user();

        // Zähle die Anzahl von Prompts, Workflows und API-Keys für den angemeldeten Benutzer
        $promptCount = Prompt::where('user_id', $user->id)->count();
        $workflowCount = Workflow::where('user_id', $user->id)->count();
        $apiKeyCount = ApiKey::where('user_id', $user->id)->count();

        // Hole die neuesten Ausführungslogs
        $recentExecutions = ExecutionLog::with('workflow')
            ->where('user_id', $user->id)
            ->latest()
            ->take(5)
            ->get()
            ->map(function ($log) {
                return [
                    'id' => $log->id,
                    'workflow_name' => $log->workflow->name,
                    'status' => $log->status,
                    'created_at' => $log->created_at,
                    'completed_at' => $log->completed_at,
                ];
            });

        // Hole die am häufigsten verwendeten Prompts (basierend auf Ausführungslogs)
        // Da keine direkte Beziehung zwischen Prompts und Logs besteht,
        // nehmen wir hier an, dass die neuesten Prompts relevant sind
        $popularPrompts = Prompt::where('user_id', $user->id)
            ->with('versions')
            ->latest()
            ->take(5)
            ->get()
            ->map(function ($prompt) {
                return [
                    'id' => $prompt->id,
                    'title' => $prompt->title,
                    'description' => $prompt->description,
                    'created_at' => $prompt->created_at,
                    'version_count' => $prompt->versions->count()
                ];
            });

        return Inertia::render('Pages/Dashboard', [
            'promptCount' => $promptCount,
            'workflowCount' => $workflowCount,
            'apiKeyCount' => $apiKeyCount,
            'recentExecutions' => $recentExecutions,
            'popularPrompts' => $popularPrompts,
        ]);
    }

}



Dateiname: Controllers\PlaygroundController.php
<?php

namespace App\Http\Controllers;

use App\Models\Prompt;
use App\Services\AiService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Illuminate\Support\Facades\Auth;

class PlaygroundController extends Controller
{
    protected $aiService;

    public function __construct(AiService $aiService)
    {
        $this->aiService = $aiService;
    }

    public function index()
    {
        $prompts = Prompt::with('currentVersion')
            ->where('user_id', Auth::id())
            ->orderBy('title')
            ->get();

        return Inertia::render('Pages/Playground/Index', [
            'prompts' => $prompts,
        ]);
    }

    public function show(Prompt $prompt)
    {
        if ($prompt->user_id !== Auth::id()) {
            abort(403);
        }

        $prompt->load('currentVersion');

        return Inertia::render('Pages/Playground/Show', [
            'prompt' => $prompt,
            'currentVersion' => $prompt->currentVersion(),
        ]);
    }

    public function test(Request $request)
    {
        $request->validate([
            'prompt_id' => 'nullable|exists:prompts,id',
            'content' => 'required|string',
            'variables' => 'nullable|array',
            'provider' => 'required|string',
            'model' => 'required|string',
            'temperature' => 'required|numeric|min:0|max:2',
            'max_tokens' => 'required|integer|min:1|max:8192',
        ]);

        // Replace variables in content
        $content = $request->content;
        if ($request->variables) {
            foreach ($request->variables as $key => $value) {
                $content = str_replace("{{" . $key . "}}", $value, $content);
            }
        }

        // Call AI Service
        $response = $this->aiService->generateCompletion(
            $request->provider,
            $request->model,
            $content,
            $request->temperature,
            $request->max_tokens
        );

        return response()->json($response);
    }

    public function compare(Request $request)
    {
        $request->validate([
            'prompt_id' => 'required|exists:prompts,id',
            'version_ids' => 'required|array',
            'version_ids.*' => 'exists:prompt_versions,id',
            'variables' => 'required|array',
            'provider' => 'required|string',
            'model' => 'required|string',
            'temperature' => 'required|numeric|min:0|max:2',
            'max_tokens' => 'required|integer|min:1|max:8192',
        ]);

        $prompt = Prompt::findOrFail($request->prompt_id);

        if ($prompt->user_id !== Auth::id()) {
            abort(403);
        }

        $results = [];

        foreach ($request->version_ids as $versionId) {
            $version = $prompt->versions()->findOrFail($versionId);

            // Replace variables in content
            $content = $version->content;
            foreach ($request->variables as $key => $value) {
                $content = str_replace("{{" . $key . "}}", $value, $content);
            }

            // Call AI Service
            $response = $this->aiService->generateCompletion(
                $request->provider,
                $request->model,
                $content,
                $request->temperature,
                $request->max_tokens
            );

            $results[] = [
                'version_id' => $versionId,
                'version_number' => $version->version,
                'response' => $response,
            ];
        }

        return response()->json(['results' => $results]);
    }
}



Dateiname: Controllers\ProfileController.php
<?php

namespace App\Http\Controllers;

use App\Http\Requests\ProfileUpdateRequest;
use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Redirect;
use Inertia\Inertia;
use Inertia\Response;

class ProfileController extends Controller
{
    /**
     * Display the user's profile form.
     */
    public function edit(Request $request): Response
    {
        return Inertia::render('profile/Edit', [
            'mustVerifyEmail' => $request->user() instanceof MustVerifyEmail,
            'status' => session('status'),
        ]);
    }

    /**
     * Update the user's profile information.
     */
    public function update(ProfileUpdateRequest $request): RedirectResponse
    {
        $request->user()->fill($request->validated());

        if ($request->user()->isDirty('email')) {
            $request->user()->email_verified_at = null;
        }

        $request->user()->save();

        return Redirect::route('profile.edit');
    }

    /**
     * Delete the user's account.
     */
    public function destroy(Request $request): RedirectResponse
    {
        $request->validate([
            'password' => ['required', 'current_password'],
        ]);

        $user = $request->user();

        Auth::logout();

        $user->delete();

        $request->session()->invalidate();
        $request->session()->regenerateToken();

        return Redirect::to('/');
    }
}



Dateiname: Controllers\PromptController.php
<?php

namespace App\Http\Controllers;

use App\Models\Prompt;
use App\Models\PromptVersion;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Illuminate\Support\Facades\Auth;

class PromptController extends Controller
{
    public function index()
    {
        $prompts = Prompt::with('currentVersion')
            ->where('user_id', Auth::id())
            ->orderBy('updated_at', 'desc')
            ->get();

        return Inertia::render('Pages/Prompts/Index', [
            'prompts' => $prompts
        ]);
    }

    public function create()
    {
        return Inertia::render('Pages/Prompts/Create');
    }

    public function store(Request $request)
    {
        $request->validate([
            'title' => 'required|string|max:255',
            'description' => 'nullable|string',
            'content' => 'required|string',
            'tags' => 'nullable|array',
        ]);

        $prompt = Prompt::create([
            'user_id' => Auth::id(),
            'title' => $request->title,
            'description' => $request->description,
            'tags' => $request->tags,
        ]);

        $promptVersion = new PromptVersion();
        $promptVersion->prompt_id = $prompt->id;
        $promptVersion->content = $request->content;
        $promptVersion->version = 1;
        $promptVersion->is_current = true;
        $promptVersion->extractVariablesFromContent();
        $promptVersion->save();

        return redirect()->route('prompts.show', $prompt)
            ->with('success', 'Prompt created successfully.');
    }

    public function show(Prompt $prompt)
    {
        if ($prompt->user_id !== Auth::id()) {
            abort(403);
        }

        $prompt->load([
            'versions' => function ($query) {
                $query->orderBy('version', 'desc');
            },
            'currentVersion' // currentVersion-Beziehung laden
        ]);

        return Inertia::render('Pages/Prompts/Show', [
            'prompt' => $prompt,
            'currentVersion' => $prompt->currentVersion, // Direkt auf die geladene Beziehung zugreifen
        ]);
    }

    public function edit(Prompt $prompt)
    {
        if ($prompt->user_id !== Auth::id()) {
            abort(403);
        }

        $prompt->load('currentVersion')->first();

        return Inertia::render('Pages/Prompts/Edit', [
            'prompt' => $prompt,
            'currentVersion' => $prompt->currentVersion,
        ]);
    }

    public function update(Request $request, Prompt $prompt)
    {
        if ($prompt->user_id !== Auth::id()) {
            abort(403);
        }

        $request->validate([
            'title' => 'required|string|max:255',
            'description' => 'nullable|string',
            'content' => 'required|string',
            'tags' => 'nullable|array',
        ]);

        $prompt->update([
            'title' => $request->title,
            'description' => $request->description,
            'tags' => $request->tags,
        ]);

        $currentVersion = $prompt->currentVersion()->first();

        // Only create a new version if content has changed
        if ($currentVersion && $currentVersion->content !== $request->content) {

            // Mark old version as not current
            $currentVersion->update(['is_current' => false]);

            // Create new version
            $promptVersion = new PromptVersion();
            $promptVersion->prompt_id = $prompt->id;
            $promptVersion->content = $request->content;
            $promptVersion->version = $currentVersion->version + 1;
            $promptVersion->is_current = true;
            $promptVersion->extractVariablesFromContent();
            $promptVersion->save();
        }

        return redirect()->route('prompts.show', $prompt)
            ->with('success', 'Prompt updated successfully.');
    }

    public function destroy(Prompt $prompt)
    {
        if ($prompt->user_id !== Auth::id()) {
            abort(403);
        }

        $prompt->delete();

        return redirect()->route('prompts.index')
            ->with('success', 'Prompt deleted successfully.');
    }

    public function setVersion(Request $request, Prompt $prompt, PromptVersion $version)
    {
        if ($prompt->user_id !== Auth::id()) {
            abort(403);
        }

        // Ensure the version belongs to this prompt
        if ($version->prompt_id !== $prompt->id) {
            abort(400, 'Invalid version');
        }

        // Update all versions to not be current
        $prompt->versions()->update(['is_current' => false]);

        // Set this version as current
        $version->update(['is_current' => true]);

        return redirect()->back()->with('success', 'Version set as current.');
    }
}



Dateiname: Controllers\SettingsController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Inertia\Inertia;

class SettingsController extends Controller
{
    public function index()
    {
        return Inertia::render('Settings');
    }

    public function update(Request $request)
    {
        // Validiere und speichere die Einstellungen
        // ...

        return redirect()->route('settings.index')->with('success', 'Einstellungen wurden aktualisiert');
    }
}



Dateiname: Controllers\WorkflowController.php
<?php

namespace App\Http\Controllers;

use App\Models\Workflow;
use App\Models\ExecutionLog;
use App\Jobs\ExecuteWorkflowJob;
use App\Services\WorkflowExecutionService;
use Illuminate\Http\Request;
use Illuminate\Support\Str;
use Inertia\Inertia;
use Illuminate\Support\Facades\Auth;

class WorkflowController extends Controller
{
    protected $workflowService;

    public function __construct(WorkflowExecutionService $workflowService)
    {
        $this->workflowService = $workflowService;
    }

//    public function index()
//    {
//        $workflows = Workflow::where('user_id', Auth::id())
//            ->orderBy('updated_at', 'desc')
//            ->get();
//
//        return Inertia::render('Pages/Workflows/Index', [
//            'workflows' => $workflows
//        ]);
//    }

    public function index()
    {
        $workflows = Workflow::where('user_id', Auth::id())
            ->orderBy('updated_at', 'desc')
            ->get();

        $recentExecutions = ExecutionLog::with('workflow')
            ->where('user_id', Auth::id())
            ->latest()
            ->take(5)
            ->get();

        return Inertia::render('Pages/Workflows/Index', [
            'workflows' => $workflows,
            'recentExecutions' => $recentExecutions
        ]);
    }

    public function create()
    {
        return Inertia::render('Pages/Workflows/Create');
    }

    public function store(Request $request)
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'description' => 'nullable|string',
            'nodes' => 'required|array',
            'edges' => 'required|array',
            'settings' => 'nullable|array',
        ]);

        $workflow = Workflow::create([
            'user_id' => Auth::id(),
            'name' => $request->name,
            'description' => $request->description,
            'nodes' => $request->nodes,
            'edges' => $request->edges,
            'settings' => $request->settings,
            'is_active' => true,
        ]);

        return redirect()->route('workflows.show', $workflow)
            ->with('success', 'Workflow created successfully.');
    }

    public function show(Workflow $workflow)
    {
        if ($workflow->user_id !== Auth::id()) {
            abort(403);
        }

        $recentExecutions = $workflow->executionLogs()
            ->orderBy('created_at', 'desc')
            ->take(5)
            ->get();

        return Inertia::render('Pages/Workflows/Show', [
            'workflow' => $workflow,
            'recentExecutions' => $recentExecutions,
        ]);
    }

    public function edit(Workflow $workflow)
    {
        if ($workflow->user_id !== Auth::id()) {
            abort(403);
        }

        return Inertia::render('Pages/Workflows/Edit', [
            'workflow' => $workflow,
        ]);
    }

    public function update(Request $request, Workflow $workflow)
    {
        if ($workflow->user_id !== Auth::id()) {
            abort(403);
        }

        $request->validate([
            'name' => 'required|string|max:255',
            'description' => 'nullable|string',
            'nodes' => 'required|array',
            'edges' => 'required|array',
            'settings' => 'nullable|array',
            'is_active' => 'boolean',
        ]);

        $workflow->update([
            'name' => $request->name,
            'description' => $request->description,
            'nodes' => $request->nodes,
            'edges' => $request->edges,
            'settings' => $request->settings,
            'is_active' => $request->is_active ?? $workflow->is_active,
        ]);

        return redirect()->route('workflows.show', $workflow)
            ->with('success', 'Workflow updated successfully.');
    }

    public function destroy(Workflow $workflow)
    {
        if ($workflow->user_id !== Auth::id()) {
            abort(403);
        }

        $workflow->delete();

        return redirect()->route('workflows.index')
            ->with('success', 'Workflow deleted successfully.');
    }

    public function execute(Request $request, Workflow $workflow)
    {
        if ($workflow->user_id !== Auth::id()) {
            abort(403);
        }

        if (!$workflow->is_active) {
            return response()->json(['error' => 'Workflow is not active'], 400);
        }

        $request->validate([
            'input_data' => 'nullable|array',
        ]);

        // Create execution log
        $executionLog = ExecutionLog::create([
            'workflow_id' => $workflow->id,
            'user_id' => Auth::id(),
            'status' => 'pending',
            'input_data' => $request->input_data ?? [],
            'started_at' => now(),
        ]);

        // Dispatch job to run workflow
        ExecuteWorkflowJob::dispatch($executionLog);

        return response()->json([
            'execution_id' => $executionLog->id,
            'message' => 'Workflow execution started',
        ]);
    }

    public function getExecutionStatus(ExecutionLog $executionLog)
    {
        if ($executionLog->user_id !== Auth::id()) {
            abort(403);
        }

        return response()->json([
            'status' => $executionLog->status,
            'started_at' => $executionLog->started_at,
            'completed_at' => $executionLog->completed_at,
            'node_results' => $executionLog->node_results,
            'output_data' => $executionLog->output_data,
            'error' => $executionLog->error,
        ]);
    }

//    public function exportWorkflow(Workflow $workflow)
//    {
//        if ($workflow->user_id !== Auth::id()) {
//            abort(403);
//        }
//
//        $exportData = [
//            'name' => $workflow->name,
//            'description' => $workflow->description,
//            'nodes' => $workflow->nodes,
//            'edges' => $workflow->edges,
//            'settings' => $workflow->settings,
//            'created_at' => $workflow->created_at,
//            'updated_at' => $workflow->updated_at,
//        ];
//
//        return response()->json($exportData);
//    }

//    public function exportWorkflow(Workflow $workflow)
//    {
//        if ($workflow->user_id !== Auth::id()) {
//            abort(403);
//        }
//
//        $exportData = [
//            'name' => $workflow->name,
//            'description' => $workflow->description,
//            'nodes' => $workflow->nodes,
//            'edges' => $workflow->edges,
//            'settings' => $workflow->settings,
//            'created_at' => $workflow->created_at,
//            'updated_at' => $workflow->updated_at,
//        ];
//
//        // JSON erstellen (mit formatierter Ausgabe für bessere Lesbarkeit)
//        $jsonData = json_encode($exportData, JSON_PRETTY_PRINT);
//
//        // Generiere einen sauberen Dateinamen basierend auf dem Workflow-Namen
//        $filename = Str::slug($workflow->name) . '-export.json';
//
//        // Zurückgeben als Download-Datei anstatt als JSON-Antwort
//        return response($jsonData)
//            ->header('Content-Type', 'application/json')
//            ->header('Content-Disposition', 'attachment; filename="' . $filename . '"');
//    }

    public function exportWorkflow(Workflow $workflow)
    {
        if ($workflow->user_id !== Auth::id()) {
            abort(403);
        }

        $exportData = [
            'name' => $workflow->name,
            'description' => $workflow->description,
            'nodes' => $workflow->nodes,
            'edges' => $workflow->edges,
            'settings' => $workflow->settings,
            'created_at' => $workflow->created_at,
            'updated_at' => $workflow->updated_at,
        ];

        // JSON erstellen (mit formatierter Ausgabe für bessere Lesbarkeit)
        $jsonData = json_encode($exportData, JSON_PRETTY_PRINT);

        // Generiere einen sauberen Dateinamen basierend auf dem Workflow-Namen
//        $filename = Str::slug($workflow->name) . '-export.json';
        $filename = strtolower(str_replace(' ', '-', $workflow->name)) . '-export.json';


        // Zurückgeben als Download-Datei anstatt als JSON-Antwort
        return response($jsonData)
            ->header('Content-Type', 'application/json')
            ->header('Content-Disposition', 'attachment; filename="' . $filename . '"');
    }

    // In WorkflowController.php:
    public function downloadWorkflow(Workflow $workflow)
    {
        if ($workflow->user_id !== Auth::id()) {
            abort(403);
        }

        $exportData = [
            'name' => $workflow->name,
            'description' => $workflow->description,
            'nodes' => $workflow->nodes,
            'edges' => $workflow->edges,
            'settings' => $workflow->settings,
            'created_at' => $workflow->created_at,
            'updated_at' => $workflow->updated_at,
        ];

        // JSON erstellen
        $jsonData = json_encode($exportData, JSON_PRETTY_PRINT);

        // Dateiname erstellen
        $filename = preg_replace('/[^a-z0-9]+/', '-', strtolower($workflow->name)) . '-export.json';

        return response($jsonData, 200, [
            'Content-Type' => 'application/json',
            'Content-Disposition' => 'attachment; filename="' . $filename . '"',
            'X-Inertia-Location' => null, // Verhindert Inertia-Navigation
        ]);
    }

    public function importWorkflow(Request $request)
    {
        $request->validate([
            'workflow_data' => 'required|json',
        ]);

        $workflowData = json_decode($request->workflow_data, true);

        if (!isset($workflowData['name']) || !isset($workflowData['nodes']) || !isset($workflowData['edges'])) {
            return response()->json(['error' => 'Invalid workflow data'], 400);
        }

        $workflow = Workflow::create([
            'user_id' => Auth::id(),
            'name' => $workflowData['name'],
            'description' => $workflowData['description'] ?? null,
            'nodes' => $workflowData['nodes'],
            'edges' => $workflowData['edges'],
            'settings' => $workflowData['settings'] ?? null,
            'is_active' => true,
        ]);

        return redirect()->route('workflows.show', $workflow)
            ->with('success', 'Workflow imported successfully.');
    }
}



Dateiname: Controllers\Auth\AuthenticatedSessionController.php
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Http\Requests\Auth\LoginRequest;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Route;
use Inertia\Inertia;
use Inertia\Response;

class AuthenticatedSessionController extends Controller
{
    /**
     * Display the login view.
     */
    public function create(): Response
    {
        return Inertia::render('auth/Login', [
            'canResetPassword' => Route::has('password.request'),
            'status' => session('status'),
        ]);
    }

    /**
     * Handle an incoming authentication request.
     */
    public function store(LoginRequest $request): RedirectResponse
    {
        $request->authenticate();

        $request->session()->regenerate();

        return redirect()->intended(route('dashboard', absolute: false));
    }

    /**
     * Destroy an authenticated session.
     */
    public function destroy(Request $request): RedirectResponse
    {
        Auth::guard('web')->logout();

        $request->session()->invalidate();

        $request->session()->regenerateToken();

        return redirect('/');
    }
}



Dateiname: Controllers\Auth\ConfirmablePasswordController.php
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Validation\ValidationException;
use Inertia\Inertia;
use Inertia\Response;

class ConfirmablePasswordController extends Controller
{
    /**
     * Show the confirm password view.
     */
    public function show(): Response
    {
        return Inertia::render('auth/ConfirmPassword');
    }

    /**
     * Confirm the user's password.
     */
    public function store(Request $request): RedirectResponse
    {
        if (! Auth::guard('web')->validate([
            'email' => $request->user()->email,
            'password' => $request->password,
        ])) {
            throw ValidationException::withMessages([
                'password' => __('auth.password'),
            ]);
        }

        $request->session()->put('auth.password_confirmed_at', time());

        return redirect()->intended(route('dashboard', absolute: false));
    }
}



Dateiname: Controllers\Auth\EmailVerificationNotificationController.php
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;

class EmailVerificationNotificationController extends Controller
{
    /**
     * Send a new email verification notification.
     */
    public function store(Request $request): RedirectResponse
    {
        if ($request->user()->hasVerifiedEmail()) {
            return redirect()->intended(route('dashboard', absolute: false));
        }

        $request->user()->sendEmailVerificationNotification();

        return back()->with('status', 'verification-link-sent');
    }
}



Dateiname: Controllers\Auth\EmailVerificationPromptController.php
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

class EmailVerificationPromptController extends Controller
{
    /**
     * Display the email verification prompt.
     */
    public function __invoke(Request $request): RedirectResponse|Response
    {
        return $request->user()->hasVerifiedEmail()
            ? redirect()->intended(route('dashboard', absolute: false))
            : Inertia::render('auth/VerifyEmail', ['status' => session('status')]);
    }
}



Dateiname: Controllers\Auth\NewPasswordController.php
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Auth\Events\PasswordReset;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Password;
use Illuminate\Support\Str;
use Illuminate\Validation\Rules;
use Illuminate\Validation\ValidationException;
use Inertia\Inertia;
use Inertia\Response;

class NewPasswordController extends Controller
{
    /**
     * Display the password reset view.
     */
    public function create(Request $request): Response
    {
        return Inertia::render('auth/ResetPassword', [
            'email' => $request->email,
            'token' => $request->route('token'),
        ]);
    }

    /**
     * Handle an incoming new password request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'token' => 'required',
            'email' => 'required|email',
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
        ]);

        // Here we will attempt to reset the user's password. If it is successful we
        // will update the password on an actual user model and persist it to the
        // database. Otherwise we will parse the error and return the response.
        $status = Password::reset(
            $request->only('email', 'password', 'password_confirmation', 'token'),
            function ($user) use ($request) {
                $user->forceFill([
                    'password' => Hash::make($request->password),
                    'remember_token' => Str::random(60),
                ])->save();

                event(new PasswordReset($user));
            }
        );

        // If the password was successfully reset, we will redirect the user back to
        // the application's home authenticated view. If there is an error we can
        // redirect them back to where they came from with their error message.
        if ($status == Password::PASSWORD_RESET) {
            return redirect()->route('login')->with('status', __($status));
        }

        throw ValidationException::withMessages([
            'email' => [trans($status)],
        ]);
    }
}



Dateiname: Controllers\Auth\PasswordController.php
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rules\Password;

class PasswordController extends Controller
{
    /**
     * Update the user's password.
     */
    public function update(Request $request): RedirectResponse
    {
        $validated = $request->validate([
            'current_password' => ['required', 'current_password'],
            'password' => ['required', Password::defaults(), 'confirmed'],
        ]);

        $request->user()->update([
            'password' => Hash::make($validated['password']),
        ]);

        return back();
    }
}



Dateiname: Controllers\Auth\PasswordResetLinkController.php
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Password;
use Illuminate\Validation\ValidationException;
use Inertia\Inertia;
use Inertia\Response;

class PasswordResetLinkController extends Controller
{
    /**
     * Display the password reset link request view.
     */
    public function create(): Response
    {
        return Inertia::render('auth/ForgotPassword', [
            'status' => session('status'),
        ]);
    }

    /**
     * Handle an incoming password reset link request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'email' => 'required|email',
        ]);

        // We will send the password reset link to this user. Once we have attempted
        // to send the link, we will examine the response then see the message we
        // need to show to the user. Finally, we'll send out a proper response.
        $status = Password::sendResetLink(
            $request->only('email')
        );

        if ($status == Password::RESET_LINK_SENT) {
            return back()->with('status', __($status));
        }

        throw ValidationException::withMessages([
            'email' => [trans($status)],
        ]);
    }
}



Dateiname: Controllers\Auth\RegisteredUserController.php
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Models\User;
use Illuminate\Auth\Events\Registered;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rules;
use Inertia\Inertia;
use Inertia\Response;

class RegisteredUserController extends Controller
{
    /**
     * Display the registration view.
     */
    public function create(): Response
    {
        return Inertia::render('auth/Register');
    }

    /**
     * Handle an incoming registration request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'email' => 'required|string|lowercase|email|max:255|unique:' . User::class,
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
        ]);

        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
        ]);

        event(new Registered($user));

        Auth::login($user);

        return redirect(route('dashboard', absolute: false));
    }
}



Dateiname: Controllers\Auth\VerifyEmailController.php
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Auth\Events\Verified;
use Illuminate\Foundation\Auth\EmailVerificationRequest;
use Illuminate\Http\RedirectResponse;

class VerifyEmailController extends Controller
{
    /**
     * Mark the authenticated user's email address as verified.
     */
    public function __invoke(EmailVerificationRequest $request): RedirectResponse
    {
        if ($request->user()->hasVerifiedEmail()) {
            return redirect()->intended(route('dashboard', absolute: false).'?verified=1');
        }

        if ($request->user()->markEmailAsVerified()) {
            event(new Verified($request->user()));
        }

        return redirect()->intended(route('dashboard', absolute: false).'?verified=1');
    }
}



